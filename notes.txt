###############################################################################
############################## SPRING CLOUD ###################################
###############################################################################

Challenges:

1. CONFIGURATION MANAGEMENT
    * Spring Cloud Config Server

 - Administración de la configuración es un desafío al tener múltiples microservicios,
   múltiples entornos para cada uno de estos microservicios y múltiples instancias por cada entorno.
 - El servidor de configuración de Spring Cloud proporciona un enfoque donde puede almacenar toda la configuración
   para todos los diferentes entornos de todos los microservicios en un repositorio Git.
 |_> Es decir toda la configuración para diferentes entornos de diferentes microservicios en un solo lugar, en una
     ubicación centralizada y se puede usar SpringCloudConfigServer para exponer esa configuración a todos los microservicios.

     CurrencyCalculationService    CurrencyExchangeService      LimitsService
                   |                           |                      |
                   |_________________          |        ______________|
                                     v         v       v
                                   SpringCloudConfigServer
                                               |
                                               v
                                              Git

2. DYNAMIC SCALE UP AND DOWN
    * Naming Server (Eureka)
    * Ribbon (Client Side Load Balancing) -> Spring Cloud LoadBalancer (update)
    * Feign (Easier REST Clients)

 - Naming Server: El servidor de nombres tiene dos características importantes:
   1. Registro del servicio para todos los microservicios.
   2. Descubrimiento de servicios
   Entonces un Microservicio puede pedirle al servidor de nombres Eureka que le brinde las instancias actuales,
   y el NamingServe le brindaría las URL de las instancias. (Relación Dinámica).

 - Ribbon para el equilibro de carga del lado del cliente, se encarga de asegurar que la carga se distribuya
   uniformemente entre las instancias existentes que obtiene el servidor de nombres (NamingServer).

 - Feign como mecanismo para escribir clientes RESTful simples.

3. VISIBILITY AND MONITORING
    * Zipkin Distributed Tracing, servidor de rastreo de distribución Zipkin.
 - Usaremos Spring Cloud Sloat para asignar ID para solicitar através de múltiples componentes y usariamos el
   rastreo distribuido Zipkin para rastrear una solicitud através de múltiples componentes.

    Una de las cosas importantes sobre los Microservicios es que estos tienen muchas características comunes.
    Por ejemplo, al registrar análisis de seguridad y cosas por el estilo, no desea implementear todas estas características
    comunes en cada Microservicio.

 - Las API Gateways brindan excelentes soluciones para este tipo de desafios.
   Utilizaremos una Netflix API Gateaway Zuul. -> Spring Cloud Gateway (update)

4. FAULT TOLERANCE
    * Hystrix -> Resilience4j (update)
 - Si un servicio está inactivo, hystrix nos ayuda a configurar una respuesta predeterminada.

Usaremos Docker para contener microservicios, ejecutaremos todos los microservicios usando Docker y Docker Compose.
Usaremos Kubernetes para orquestar todos nuestros microservicios.


###############################################################################
############################## DEPENDENCIAS ###################################
###############################################################################

Spring Boot DevTools: Provee una configuración para una mejor experiencia de desarrollo
Spring Boot Actuator: Para monitorear y administrar la aplicación
Spring Web: Porque queremos construir una API Rest
Config Client (Spring Cloud Config): Para que nos sea útil hablar con un servidor de configuración de la nube

###############################################################################
############################### PROPERTIES ####################################
###############################################################################

spring.application.name=currency-exchange -> Definimos el nombre de la aplicación
spring.config.import=optional:configserver:http://localhost:8888 -> Definimos la ruta de la configuración central
server.port=8000 -> Definimos el puerto donde correrá la aplicación, peor en VM options podemos sobreescribirlo

spring.jpa.show-sql=true
spring.datasource.url=jdbc:h2:mem:testdb -> Definimos el nombre de nuestra base de datos (testdb) para que no se cree
                                            uno aleatorio.
spring.h2.console.enabled=true -> Para ver los detalles que están presentes en la base de datos

OJO: Al tener nuestro archivo data.sql en Resources, cada vez que se inicia la aplicación cargará este archivo para la BD.

###############################################################################
########################## DESCRIPCIÓN DE PASOS ###############################
###############################################################################

- Se creó el repositorio git git-localconfig-repo
- Se le agregó el archivo limits-service.properties
- Se pasaron los valores que contenia limits-service\...\application.properties a limits-service.properties
- Se añadió la anotación @EnableConfigServer a SpringCloudConfigServerApplication.java
- Se define el puerto donde correrá SpringCloudConfigServerApplication el cual es 8888
- Se añadió en spring.cloud.config.server.git.uri la ruta donde se encuentra el repositorio git (Centralized Configuration)
- Probamos que funcione al consultar en el navegador por la URL http://localhost:8888/limits-service/default

- Definimos el nombre del servicio limits-service en su application.properties name=limits-service
- Cuando ejecutamos SpringCloudConfigServerApplication y LimitsServiceApplication, LimitsServiceApplication usará
  la configuración centralizada del repositorio git


- Más adelante se tendrá varias instancias de "Currency Conversion Microservice", y se necesitará saber qué instancia
  del microservicio Currency Exchange está proporcionando la respuesta, la instancia 1, 2 o 3 (ports: 8000, 8001, 8002)

                                  Currency Conversion Microservice
                                                 |
                                                 v
                                           Load Balancer  ---> Naming Server
                 ___________________________|    |    |___________________________
                |                                |                                |
                v                                v                                v
 Currency Exchange - Instance 1    Currency Exchange - Instance 2    Currency Exchange - Instance 3

- Agregaremos una variable con los detalles del entorno para poder rastrear la instancia de Currency Exchange
- Creamos más instancias de un servicio en Run > Edit Configuration, en (+) creamos otro CurrencyExchangeServiceApplication
  al colocar en el Main class: com.arimagroup.currencyexchangeservice.CurrencyExchangeServiceApplication,
  luego en VM options: -Dserver.port=8001 (puerto siguiente al 8000).
- De esta forma cuando llamemos al "Microservicio de Currency Exchange" desde "Currency Conversion Microservice"
  sabremos qué instancia del "Microservicio de Currency Exchange" está respondiendo realmente.


- Para llamar a un microservicio desde otro, usamos
  ResTemplate().getForEntity(URL Microservice, tipo de clase resultado, uri variables)

  ResponseEntity<CurrencyConversion> responseEntity = new RestTemplate().getForEntity("http://localhost:8000/
                                                    currency-exchange/from/{from}/to/{to}", CurrencyConversion.class,
                                                    uriVariables);
  * El "tipo de clase resultado" no necesariamente es la misma que el del response del microservicio a llamar,
  lo que sucederá, es que los campos comunes se llenaran con los valores del response.
  * Las uri variables se envian por medio de un HashMap<String, String>

################################## FEIGN ######################################

- Para llamar a un microservicio desde otro, sin usar tanto código (RestTemplate) creamos un proxy con Feign.
  Debemos añadir la anotación @EnableFeignClients en el MicroserviceApplication de donde queremos llamar.
  Luego crear un interface proxy con la anotación @FeignClient(name = "currency-exchange", url = "localhost:8000")
   Los cuales son el nombre del microservicio a llamar y la url donde corre
  Además colocaremos el método que queremos llamar del otro servicio.

############################## NAMING SERVER ##################################

- Cuando un microservicio se quiere comunicar con otro, preguntará al registro de servicios cuales son las direcciones
  del otro servicio.
- Creamos el microservicio naming-server con las dependencias: devtools, actuator y Eureka Server
- Agregamos la anotación @EnableEurekaServer al NamingServerApplication