###############################################################################
############################## SPRING CLOUD ###################################
###############################################################################

Challenges:

1. CONFIGURATION MANAGEMENT
    * Spring Cloud Config Server

 - Administración de la configuración es un desafío al tener múltiples microservicios,
   múltiples entornos para cada uno de estos microservicios y múltiples instancias por cada entorno.
 - El servidor de configuración de Spring Cloud proporciona un enfoque donde puede almacenar toda la configuración
   para todos los diferentes entornos de todos los microservicios en un repositorio Git.
 |_> Es decir toda la configuración para diferentes entornos de diferentes microservicios en un solo lugar, en una
     ubicación centralizada y se puede usar SpringCloudConfigServer para exponer esa configuración a todos los microservicios.

     CurrencyCalculationService    CurrencyExchangeService      LimitsService
                   |                           |                      |
                   |_________________          |        ______________|
                                     v         v       v
                                   SpringCloudConfigServer
                                               |
                                               v
                                              Git

2. DYNAMIC SCALE UP AND DOWN
    * Naming Server (Eureka)
    * Ribbon (Client Side Load Balancing) -> Spring Cloud LoadBalancer (update)
    * Feign (Easier REST Clients)

 - Naming Server: El servidor de nombres tiene dos características importantes:
   1. Registro del servicio para todos los microservicios.
   2. Descubrimiento de servicios
   Entonces un Microservicio puede pedirle al servidor de nombres Eureka que le brinde las instancias actuales,
   y el NamingServe le brindaría las URL de las instancias. (Relación Dinámica).

 - Ribbon para el equilibro de carga del lado del cliente, se encarga de asegurar que la carga se distribuya
   uniformemente entre las instancias existentes que obtiene el servidor de nombres (NamingServer).

 - Feign como mecanismo para escribir clientes RESTful simples.

3. VISIBILITY AND MONITORING
    * Zipkin Distributed Tracing, servidor de rastreo de distribución Zipkin.
 - Usaremos Spring Cloud Sloat para asignar ID para solicitar através de múltiples componentes y usariamos el
   rastreo distribuido Zipkin para rastrear una solicitud através de múltiples componentes.

    Una de las cosas importantes sobre los Microservicios es que estos tienen muchas características comunes.
    Por ejemplo, al registrar análisis de seguridad y cosas por el estilo, no desea implementear todas estas características
    comunes en cada Microservicio.

 - Las API Gateways brindan excelentes soluciones para este tipo de desafios.
   Utilizaremos una Netflix API Gateaway Zuul. -> Spring Cloud Gateway (update)

4. FAULT TOLERANCE
    * Hystrix -> Resilience4j (update)
 - Si un servicio está inactivo, hystrix nos ayuda a configurar una respuesta predeterminada.

Usaremos Docker para contener microservicios, ejecutaremos todos los microservicios usando Docker y Docker Compose.
Usaremos Kubernetes para orquestar todos nuestros microservicios.


###############################################################################
############################## DEPENDENCIAS ###################################
###############################################################################

Spring Boot DevTools: Provee una configuración para una mejor experiencia de desarrollo
Spring Boot Actuator: Para monitorear y administrar la aplicación
Spring Web: Porque queremos construir una API Rest
Config Client (Spring Cloud Config): Para que nos sea útil hablar con un servidor de configuración de la nube

###############################################################################
############################### PROPERTIES ####################################
###############################################################################

spring.application.name=currency-exchange -> Definimos el nombre de la aplicación
spring.config.import=optional:configserver:http://localhost:8888 -> Definimos la ruta de la configuración central
server.port=8000 -> Definimos el puerto donde correrá la aplicación, peor en VM options podemos sobreescribirlo

spring.jpa.show-sql=true
spring.datasource.url=jdbc:h2:mem:testdb -> Definimos el nombre de nuestra base de datos (testdb) para que no se cree
                                            uno aleatorio.
spring.h2.console.enabled=true -> Para ver los detalles que están presentes en la base de datos

OJO: Al tener nuestro archivo data.sql en Resources, cada vez que se inicia la aplicación cargará este archivo para la BD.

###############################################################################
########################## DESCRIPCIÓN DE PASOS ###############################
###############################################################################

######################## CENTRALIZED CONFIGURATION ############################

- Se creó el repositorio git git-localconfig-repo
- Se le agregó el archivo limits-service.properties
- Se pasaron los valores que contenia limits-service\...\application.properties a limits-service.properties
- Se añadió la anotación @EnableConfigServer a SpringCloudConfigServerApplication.java
- Se define el puerto donde correrá SpringCloudConfigServerApplication el cual es 8888
- Se añadió en spring.cloud.config.server.git.uri la ruta donde se encuentra el repositorio git (Centralized Configuration)
- Probamos que funcione al consultar en el navegador por la URL http://localhost:8888/limits-service/default

- Definimos el nombre del servicio limits-service en su application.properties name=limits-service
- Cuando ejecutamos SpringCloudConfigServerApplication y LimitsServiceApplication, LimitsServiceApplication usará
  la configuración centralizada del repositorio git
- Se podrá manejar distintos perfiles de configuración, creando otras configuraciones agregando -dev, -qa
  al nombre del archivo.
     > limits-service.properties
     > limits-service-dev.properties
     > limits-service-qa.properties
  El primer perfil será el default
- Se pueden consultar desde un navegador mediante:
  localhost:8888/limits-service/qa
  localhost:8888/limits-service/default


- Más adelante se tendrá varias instancias de "Currency Conversion Microservice", y se necesitará saber qué instancia
  del microservicio Currency Exchange está proporcionando la respuesta, la instancia 1, 2 o 3 (ports: 8000, 8001, 8002)

                                  Currency Conversion Microservice
                                                 |
                                                 v
                                           Load Balancer  ---> Naming Server
                 ___________________________|    |    |___________________________
                |                                |                                |
                v                                v                                v
 Currency Exchange - Instance 1    Currency Exchange - Instance 2    Currency Exchange - Instance 3

- Agregaremos una variable con los detalles del entorno para poder rastrear la instancia de Currency Exchange
- Creamos más instancias de un servicio en Run > Edit Configuration, en (+) creamos otro CurrencyExchangeServiceApplication
  al colocar en el Main class: com.arimagroup.currencyexchangeservice.CurrencyExchangeServiceApplication,
  luego en VM options: -Dserver.port=8001 (puerto siguiente al 8000).
- De esta forma cuando llamemos al "Microservicio de Currency Exchange" desde "Currency Conversion Microservice"
  sabremos qué instancia del "Microservicio de Currency Exchange" está respondiendo realmente.


- Para llamar a un microservicio desde otro, usamos
  ResTemplate().getForEntity(URL Microservice, tipo de clase resultado, uri variables)

  ResponseEntity<CurrencyConversion> responseEntity = new RestTemplate().getForEntity("http://localhost:8000/
                                                    currency-exchange/from/{from}/to/{to}", CurrencyConversion.class,
                                                    uriVariables);
  * El "tipo de clase resultado" no necesariamente es la misma que el del response del microservicio a llamar,
  lo que sucederá, es que los campos comunes se llenaran con los valores del response.
  * Las uri variables se envian por medio de un HashMap<String, String>

################################## FEIGN ######################################

- Para llamar a un microservicio desde otro, sin usar tanto código (RestTemplate) creamos un proxy con Feign.
  Debemos añadir la anotación @EnableFeignClients en el MicroserviceApplication de donde queremos llamar.
  Luego crear un interface proxy con la anotación @FeignClient(name = "currency-exchange", url = "localhost:8000")
   Los cuales son el nombre del microservicio a llamar y la url donde corre
  Además colocaremos el método que queremos llamar del otro servicio.

############################## NAMING SERVER ##################################

- Cuando un microservicio se quiere comunicar con otro, preguntará al registro de servicios cuales son las direcciones
  del otro servicio.
- Creamos el microservicio naming-server con las dependencias: devtools, actuator y Eureka Server
- Agregamos la anotación @EnableEurekaServer al NamingServerApplication

- Para que un microservicio se conecte a Eureka solo es necesario agregar la dependencia en su pom.xml
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

############################## LOAD BALANCER ##################################

- FeignClient se comunicará con Eureka para captar las instancias del microservicio y equilibre las cargas entre ellos.
- spring-cloud-...-eureka-client importa la dependencia spring-cloud-loadbalancer
- Podemos ver todas las instancias cargadas en Eureka http://localhost:8761/

############################### API GATEWAY ###################################

- Usamos API Gateway para implementar todas las características comunes de los microservicios como
  autenticación, autorización, ...
- Creamos el microservicio api-gateway con las dependencias: Devtools, Actuator, Eureka client, Gateway
  Siendo Gateway que nos ayuda a implementar temas como seguridad, monitoreo ...
- Habilitamos la comunicación de la API Gateway con Eureka con spring.cloud.gateway.discovery.locator.enabled=true
- Eureka lista las aplicaciones, y los nombres el cual tiene de cada uno, por el cual podemos hacer uso para llamarlas
  Por ejm:
    http://localhost:8000/currency-exchange/from/USD/to/INR ->
    http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/USD/to/INR
  http://localhost:8765/CURRENCY-EXCHANGE apunta a http://localhost:8000 (instancia)
- De esta manera se puede llamar cualquier servicio registrado en Eureka con API Gateway
- Si se desea implementar un login, podemos implementarla en API Gateway y solo permitir aquellos servicios
  que estan autenticados en sus microservicios.

- Para usar urls específicas, con el nombre que queremos debemos desactivar el locator
- Configuramos nuestra url cuyo path es currecy-exchange ("/currency-exchange/**",
  ejm: localhost:8765/currency-conversion-new/from/USD/to/INR/quantity/10) definiendo que la uri de esta será
  "lb://currency-exchange", donde lb representa al Load Balancer Eureka con el API Gateway localhost:8765,
  por lo que nuestra url estaría apuntando a uri/path ("lb://currency-exchange/currecy-exchange/**") =>
  "localhost:8765:/currency-exchange/currecy-exchange/**"
- Resumen, cuando se llame a "http://localhost:8765/currency-conversion/from/USD/to/INR/quantity/10" ==
    /currecy-exchange/** == path
  este estará apuntando a "http://localhost:8765/currency-conversion/currency-conversion/from/USD/to/INR/quantity/10"
- También se podrá reemplazar el valor de un path con .filters() rewritePath

- Quiero registrar cada solicitud que pasa por la API Gateway

############################# FAULT TOLERANCE #################################
############################### RESILIENCE4J ##################################

################################### RETRY #####################################

- Agregamos las dependencias spring-boot-starter-aop, resilience4j-spring-boot2 en el microservicio donde queremos
  usar Tolerancia a fallos.
- @Retry nos permite llamar hasta 3 veces un método que lanza un error, para intentar levantarlo,
  si el reintento falla, solo entonces devuelve un error.
- Podemos usar el modo default (3 intentos), con @Retry(name = "default")
- Si queremos especificar la cantidad de intentos podemos colocar un nombre @Retry(sample-api),
  y colocar en el application.properties lo siguiente:
  resilience4j.retry.instances.sample-api.max-attempts=5
- Podemos definir el tiempo de espera entre intentos con:
  resilience4j.retry.instances.sample-api.wait-duration=1s
- Podemos establecer que después de cada intento el tiempo de espera aumente exponencialmente
  resilience4j.retry.instances.sample-api.enable-exponential-backoff=true
- Podemos definir un método que se llamará en caso falle un método con fallbackMethod
  @Retry(name = "sample-api", fallbackMethod = "hardcodedResponse")
- Luego creamos ese método teniendo como parametro una excepción para capturar en caso de error.
  public String hardcodedResponse(Exception exception) {...}

############################## CIRCUIT BREAKER ################################

- En un estado CERRADO siempre llamará al microservicio dependiente.
- En un estado ABIERTO no llamará al microservicio dependiente, retornará directamente la respuesta de reserva.
- En un estado HALF OPEN, un circuit breaker enviaría un porcentaje de solicitudes al microservicio.

- ¿Cuándo cambia de estado un circuit breaker?
- inicia con estado CLOSED, después de muchas llamadas fallidas cambia a OPEN, después de un tiempo cambia de estado
  a HALF OPEN, en este estado el Circuit breaker intentará ver si el microservicio está activo, enviando
  un porcentaje de solicitudes al microservicio, si no obtiene las respuestas adecuadas, volverá a OPEN.

################################ RATE LIMITER #################################

- Definimos la cantidad de llamadas que se pueden realizar en un tramo de tiempo
resilience4j.ratelimiter.instances.default.limit-for-period=2
resilience4j.ratelimiter.instances.default.limit-refresh-period=10s

################################## BULKHEAD ###################################

- Definimos la cantidad de llamadas simultaneas
resilience4j.bulkhead.instances.sample-bulk.max-concurrent-calls=10


###############################################################################
################################# DOCKER ######################################
###############################################################################

- Se creará un Docker image para cada microservico, y contendrá las herramientas que necesite como JDK, Python, NodeJS,
  la aplicación y sus dependencias.
- Una vez completa el Docker image se puede ejecutar como contenedores de la misma manera en cualquier infraestructura,
  en una máquina local, AWS, Azure...

- Las imagenes se encuentran en Docker Hub (repo de imagenes)
- La images es una versión estática y el contenedor es una versión en ejecución.
- Para la misma imagen se puede tener varios contenedores en ejecución.
- Al ejecutar un comando, este se realiza desde el Docker Client, y este se envía al Docker Daemon para su ejecución-
- El Docker Daemon es responsable de los contenedores, administrar las imágenes locales y de extraer del registro de
  imágenes o enviar una imagen creada localmente a un registro de imágenes.


  DOCKER ARCHITECTURE:

                                           Docker Client
                                                 |
                                                 v
                                           Docker Daemon
                 ___________________________|    |    |___________________________
                |                                |                                |
                v                                v                                v
            Containers                      Local Images                    Image Registry
                                                                    (nginx, mysql, eureka, your-app)


- Cuando se realiza el Stop de un contenedor, la señal que se envía al contenedor es SIGTERM, lo que significa es que
  el contenedor se tome su tiempo para detener sus conexiones para realizar un apagado limpio.
- Cuando se realiza el Kill de un contenedor, se envía la señal SIGKILL y detiene inmediatamente el contenedor.

################################ COMMANDS #####################################
container id: 38155a29830 ...
<container_id> : Es el container id, el cual solo es necesario ingresar los primeros caracteres, ejm: 38155

docker logs -f <container_id> , ejm: docker logs -f 38155 : Visualizar los logs del contenedor

docker run <image> : Corre la imagen, si no está disponible en el archivo local, lo descarga y crea un contenedor.
    -p <local port: container port> : Asignamos un puerto de nuestro local para que se comunique con un puerto del contenedor
    - d : --detach, por default los contenedores corren en primer plano, con esto lo pasamos a segundo plano
    --name <container name> : asignamos un nombre a nuestro contenedor
    --restart=<option> : Define si cada vez que se reinicia el Docker y el Daemos el contenedor se inicie automáticamente [always/no]
    -m <quantity_memory> : Define la cantidad de memoria asignada al contenedor, ejm: -m 512m => 512 MegaBytes ó -m 1G => 1 GigaByte
    --cpu-quota 100000 : Defina el porcentaje de uso de cpu, 10^5 = 100%, 5000 = 5%
    Command example: docker run -p <local port: container port> -d --restart=no --name <container name> <image>
docker run <image> == docker container run <image>
docker container ls : Lista los contenedores en ejecución
docker container ls -a: Lista los contenedores en ejecución y detenidos
docker container stop <container_id> : Detiene limpiamente un contenedor en ejecución
docker container kill <container_id> : Detiene inmediatamente un contenedor en ejecución
docker container pause <container_id> : Pausa el contenedor
docker container unpause <container_id> : Activa el contenedor
docker container inspect <container_id> : Muestra los metadatos del contenedor, imagen de donde viene ...
docker container prune : Elimina los contenedores detenidos

docker top <container_id> : Lista los procesos ejecutándose en el contenedor

docker events : Muestra los eventos que se generan por los contenedores como network disconnect, container stop, volumen unmount

docker stats : Muestra las estadisticas sobre los contenedores que se ejecutan (% Memory, %CPU, ...)

docker system df : Ayuda a ver lo que maneja el Docker Daemon, la administración de imagenes y contenedores

docker tag <repository>:<tag> <repository>:<new tag> : Esto creará una imagen clon con el nuevo tag definido
    EJM: docker tag nginx:1.0.0.RELEASE nginx:latest, luego con docker images o docker image ls visualizaremos

docker pull <image> , ejm: docker pull mysql : Descarga la imagen que queremos

docker image ls: Lista las imagenes
docker image history <image_id o repository+tag> , ejm: docker image history f8049a029560 : Esto mostrará los pasos necesarios
    para crear esa imagen específica.
docker image inspect <image_id> : Inspeccionar configuración de la imagen
docker image remove <image_id> : Eliminará la imagen de la máquina local